#!/bin/bash
#
#  i3-volume
#
#  Volume control and volume notifications for i3wm.
#
#  Requires:
#    alsa-utils or pulseaudio-utils
#    awk (POSIX compatible)
#
#  Optional:
#    A libnotify compatible notification daemon such as notify-osd or dunst
#    notify-send (libnotify) or dunstify (dunst)
#
#  Copyright (c) 2016 Beau Hastings. All rights reserved.
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3-volume

# Helper that is `true` if a string is empty
empty() {
    [[ -z $1 ]]
}

# Helper that is `true` if a string is not empty
not_empty() {
    [[ -n $1 ]]
}

# Helper that is `true` if a variable is set
isset() {
    [[ -v $1 ]]
}

# Executes `pacmd list-sinks` or return its output if called previously
pacmd_list_sinks() {
    if $OPT_LISTEN || empty "$PACMD_LIST_SINKS_OUTPUT"; then
        PACMD_LIST_SINKS_OUTPUT=$(pacmd list-sinks)
    fi
    echo "$PACMD_LIST_SINKS_OUTPUT"
}

# Invalidates the `pacmd list-sinks` "cache"
invalidate_pacmd_list_sinks() {
    unset PACMD_LIST_SINKS_OUTPUT
}

# Get default sink name
get_default_sink_name() {
    pacmd stat | awk -F": " '/^Default sink name: /{print $2}'
}

# Get the index of a sink name
#
# Arguments
#   Sink name   (string) Symbolic name of sink.
get_sink_index() {
    local -r sink=$1

    pacmd_list_sinks |
        awk -W posix '/^[ \t*]+index: /{idx = $3}
                      /^[ \t]+name: / {insink = $2 == "<'$sink'>"; if (insink) { print idx }; exit}'
}

# Get the volume as a percentage.
get_volume() {
    if $OPT_USE_AMIXER; then
        get_volume_amixer $CARD $MIXER
    else
        get_volume_pulseaudio $SINK
    fi
}

# Get the volume as a percentage.
#
# Arguments
#   Sink name   (string) Symbolic name of sink.
get_volume_pulseaudio() {
    local -r sink=$1

    pacmd_list_sinks |
        awk -W posix '/^[ \t]+name: /{insink = $2 == "<'$sink'>"}
                      /^[ \t]+volume: / && insink {gsub("%,?", ""); print $5; exit}'
}

# Get the volume as a percentage.
#
# Arguments
#   Card        (integer) Card number to control.
#   Mixer       (string) Name of the mixer.
get_volume_amixer() {
    local -r card=$1
    local -r mixer=$2
    local volume

    if not_empty "$card"; then
        volume=$(amixer -c "$card" -- sget "$mixer") || exit 1
    else
        volume=$(amixer sget "$mixer") || exit 1
    fi

    echo $volume | awk -W posix -F'[][]' '/dB/ { gsub("%", ""); print $2 }'
}

# Get the max volume as a percentage.
#
# Arguments
#   Sink name   (string) Symbolic name of sink.
get_base_volume_pulseaudio() {
    local -r sink=$1

    pacmd_list_sinks |
        awk -W posix '/^[ \t]+name: /{insink = $2 == "<'$sink'>"}
                      /^[ \t]+base volume: / && insink {gsub("%", ""); print $5; exit}'
}

# Increase volume relative to current volume.
#
# Arguments:
#   Step        (integer) Percentage to increase by.
#   Max Volume  (optional) (integer|percentage) Maximum volume limit.
raise_volume() {
    local -r step=$1
    local -r max_vol=$2

    if not_empty "$max_vol"; then
        local -r vol=$(get_volume)

        if (( $vol + $step > $max_vol )); then
            return
        fi
    fi

    if $OPT_USE_AMIXER; then
        raise_volume_amixer "$CARD" "$step"
    else
        raise_volume_pulseaudio "$SINK" "$step"
    fi
}

# Increase volume relative to current volume using pulseaudio.
#
# Arguments:
#   Sink name   (string)  Symbolic name of sink.
#   Step        (integer) Percentage to increase by.
raise_volume_pulseaudio() {
    local -r sink=$1
    local -r step=${2:-5}

    set_volume_pulseaudio "$sink" "+${step}%"
}

# Increase volume relative to current volume using amixer.
#
# Arguments:
#   Card        (integer) Card number to control.
#   Step        (integer) Percentage to increase by.
raise_volume_amixer() {
    local -r card=$1
    local -r step=${2:-5}

    set_volume_amixer "$card" "${step}%+"
}

# Decrease volume relative to current volume.
#
# Arguments:
#   Step        (integer) Percentage to decrease by.
lower_volume() {
    if $OPT_USE_AMIXER; then
        lower_volume_amixer "$CARD" "$1"
    else
        lower_volume_pulseaudio "$SINK" "$1"
    fi
}

# Decrease volume relative to current volume using pulseaudio.
#
# Arguments:
#   Sink name   (string)  Symbolic name of sink.
#   Step        (integer|percentage) Percentage to decrease by.
lower_volume_pulseaudio() {
    local -r sink=$1
    local -r step=${2:-5}

    set_volume_pulseaudio "$sink" "-${step}%"
}

# Decrease volume relative to current volume using amixer.
#
# Arguments:
#   Card        (integer) Card number to control.
#   Step        (integer) Percentage to decrease by.
lower_volume_amixer() {
    local -r card=$1
    local -r step=${2:-5}

    set_volume_amixer "$card" "${step}%-"
}

# Set volume.
#
# Arguments:
#   Volume      (integer|linear factor|percentage|decibel)
#   Max Volume  (optional) (integer|percentage) Maximum volume limit.
set_volume() {
    local -r vol=$1
    local -r max_vol=$2

    if not_empty "$max_vol" && (( $vol > $max_vol )); then
        return
    fi

    if $OPT_USE_AMIXER; then
        set_volume_amixer "$CARD" "${vol}%"
    else
        set_volume_pulseaudio "$SINK" "${vol}%"
    fi
}

# Set volume using pulseaudio.
#
# Arguments:
#   Sink name   (string) Symbolic name of sink.
#   Volume      (integer|linear factor|percentage|decibel)
set_volume_pulseaudio() {
    local -r sink=$1
    local -r vol=$2

    invalidate_pacmd_list_sinks

    pactl set-sink-volume "$sink" "$vol" || pactl set-sink-volume "$sink" -- "$vol"
}

# Set volume using amixer.
#
# Arguments:
#   Card        (integer) Card number to control.
#   Volume      (integer|linear factor|percentage|decibel)
set_volume_amixer() {
    local -r card=$1
    local -r vol=$2

    if not_empty "$card"; then
        amixer -q -c "$card" -- set $MIXER "$vol"
    else
        amixer -q set $MIXER "$vol"
    fi
}

# Toggle mute.
toggle_mute() {
    if $OPT_USE_AMIXER; then
        toggle_mute_amixer "$CARD"
    else
        toggle_mute_pulseaudio "$SINK"
    fi
}

# Toggle mute using pulseaudio.
#
# Arguments:
#   Sink name   (string) Symbolic name of sink.
toggle_mute_pulseaudio() {
    local -r sink=$1

    invalidate_pacmd_list_sinks

    pactl set-sink-mute "$sink" toggle
}

# Toggle mute using amixer.
#
# Arguments:
#   Card        (integer) Card number to control.
toggle_mute_amixer() {
    local -r card=$1

    if not_empty "$card"; then
        amixer -q -c "$card" -- set $MIXER toggle
    else
        amixer -q set $MIXER toggle
    fi
}

# Check if muted.
is_muted() {
    if $OPT_USE_AMIXER; then
        return $(is_muted_amixer "$CARD")
    else
        return $(is_muted_pulseaudio "$SINK")
    fi
}

# Check if sink is muted.
#
# Arguments:
#   Sink name    (string) Symbolic name of sink.
#
# Returns:
#   0 when true, 1 when false.
is_muted_pulseaudio() {
    local -r sink=$1

    muted=$(pacmd_list_sinks |
                   awk -W posix '/^[ \t]+name: /{insink = $2 == "<'$sink'>"}
                                 /^[ \t]+muted: / && insink {print $2; exit}')

    [[ $muted = yes ]]
}

# Check if card is muted.
#
# Arguments:
#   Card        (integer) Card number to control.
#
# Returns:
#   0 when true, 1 when false.
is_muted_amixer() {
    local -r card="$1"
    local output

    if not_empty "$card"; then
        output=$(amixer -c "$card" -- sget $MIXER) || exit 1
    else
        output=$(amixer sget $MIXER) || exit 1
    fi

    status=$(echo $output | awk -W posix -F'[][]' '/dB/ { print $6 }')

    [[ $status = off ]]
}

# Gets an icon for the provided volume.
#
# Arguments:
#   Volume      (integer) An integer indicating the volume.
#
# Returns:
#   The volume icon name.
get_volume_icon() {
    local -r vol=$1
    local icon

    if $OPT_USE_FULLCOLOR_ICONS; then
        if (( $vol >= 70 )); then icon=${ICONS[1]}
        elif (( $vol >= 40 )); then icon=${ICONS[3]}
        elif (( $vol > 0 )); then icon=${ICONS[2]}
        else icon=${ICONS[2]}
        fi
    else
        # Get overamplified icon if available, otherwise default to high volume icon
        if (( $vol > 100 )); then icon=${ICONS_SYMBOLIC[4]:-${ICONS_SYMBOLIC[1]}}
        elif (( $vol >= 70 )); then icon=${ICONS_SYMBOLIC[1]}
        elif (( $vol >= 40 )); then icon=${ICONS_SYMBOLIC[3]}
        elif (( $vol > 0 )); then icon=${ICONS_SYMBOLIC[2]}
        else icon=${ICONS_SYMBOLIC[2]}
        fi
    fi

    echo "$icon"
}

# Display a notification indicating muted or current volume.
notify_volume() {
    local -r vol=$(get_volume)
    local icon

    if is_muted; then
        text="Volume muted"

        if $OPT_USE_FULLCOLOR_ICONS; then
            icon=${ICONS[0]}
        else
            icon=${ICONS_SYMBOLIC[0]}
        fi
    else
        printf -v text "Volume %3s%%" $vol

        icon=$(get_volume_icon "$vol")

        if $OPT_SHOW_VOLUME_PROGRESS; then
            local -r progress=$(get_progress_bar "$vol")
            text="$text $progress"
        fi
    fi

    case "$NOTIFICATION_METHOD" in
        xosd)
            notify_volume_xosd "$vol" "$text"
            ;;
        herbe)
            notify_volume_herbe "$text"
            ;;
        *)
            notify_volume_libnotify "$vol" "$icon" "$text"
            ;;
    esac
}

# Send notifcation for libnotify-compatible notification daemons.
#
# Arguments:
#   Volume      (integer) An integer indicating the volume.
#   Icon        (string) Icon to display.
#   Text        (string) Notification text.
notify_volume_libnotify() {
    local -r vol=$1
    local -r icon=$2
    local -r text=${@:3}

    if $OPT_USE_DUNSTIFY; then
        dunstify -i "$icon" -t $expires -h int:value:"$vol" -h string:synchronous:volume "$text" -r 1000
    else
        notify-send -i "$icon" -t $expires -h int:value:"$vol" -h string:synchronous:volume "$text" -h string:x-canonical-private-synchronous:i3-volume
    fi
}

# Send notification to XOSD.
#
# Arguments:
#   Volume      (integer) An integer indicating the volume.
#   Text        (string) Notification text.
notify_volume_xosd() {
    local -r vol=$1
    local -r text=${@:2}
    local -r delay=$(ms_to_secs $expires)
    local percentage

    if is_muted; then
        color=$COLOR_MUTED
        percentage=0
    else
        color=$(volume_color $vol)
        percentage=$vol
    fi

    osd_cat --align center -b percentage -P "$percentage" -d $delay -p top -A center -c "$color" -T "$text" -O 2 -u "$COLOR_XOSD_OUTLINE" & disown
}


# Send notification to herbe.
#
# Arguments:
#   Text        (string) Notification text.
#
# Note: a patch with a notify-send script for herbe, not in the current version at this
#       time but would make this irrelevant. See https://github.com/dudik/herbe/pull/10
notify_volume_herbe() {
    local -r text=$@

    # Dismiss existing/pending notifications to prevent queuing
    pkill -SIGUSR1 herbe

    herbe "$text" & disown
}

# Updates the status line.
#
# Arguments:
#   signal  (string) The signal used to update the status line.
#   proc    (string) The name of the status line process.
update_statusline() {
    local -r signal=$1
    local -r proc=$2

    pkill "-$signal" "$proc"
}

# Generates a progress bar for the provided value.
#
# Arguments:
#   Percentage      (integer) Percentage of progress.
#   Maximum         (integer) Maximum percentage. (default: 100)
#   Divisor         (integer) For calculating the ratio of blocks to progress (default: 5)
#
# Returns:
#   The progress bar.
get_progress_bar() {
    local -r percent=$1
    local -r max_percent=${2:-100}
    local -r divisor=${3:-5}
    local -r progress=$((($percent > $max_percent ? $max_percent : $percent) / $divisor))

    printf -v bar "%*s" $progress
    echo "${bar// /█}"
}

# Add a suffix to symbolic icon names.
apply_SYMBOLIC_ICON_SUFFIX() {
    for i in "${!ICONS_SYMBOLIC[@]}"; do
        ICONS_SYMBOLIC[$i]="${ICONS_SYMBOLIC[$i]}${SYMBOLIC_ICON_SUFFIX}"
    done
}

# Get the flags of the PulseAudio sink.
#
# Arguments
#   Sink name   (string) Symbolic name of sink.
get_sink_flags() {
    local -r sink=$1

    pacmd_list_sinks |
        awk -W posix '/^[ \t]+name: /{insink = $2 == "<'$sink'>"}
                      /^[ \t]+flags: / && insink {for(i=2;i<=NF;++i)printf $i FS; exit}'
}

# Outputs the current volume.
output_volume() {
    case "$OUTPUT_MODE" in
        i3blocks)
            output_volume_i3blocks
            ;;
        xob)
            output_volume_xob
            ;;
        generic)
            output_volume_generic
            ;;
        *)
            output_volume_custom
            ;;
    esac
}

# Outputs the current volume.
output_volume_generic() {
    if is_muted; then
        echo MUTE
    else
        echo "$(get_volume)%"
    fi
}

# Outputs the current volume using a custom format string.
#
# Format options:
#   %v = volume percentage or "MUTE" when muted
output_volume_custom() {
    local -r format=$OUTPUT_MODE

    if is_muted; then
        echo -ne "${format//\%v/MUTE}"
    else
        echo -ne "${format//\%v/$(get_volume)%}"
    fi
}

# Outputs the current volume for i3blocks.
output_volume_i3blocks() {
    local short_text
    local full_text

    if is_muted; then
        short_text="<span color=\"$COLOR_MUTED\">MUTE</span>\n"
        full_text="<span color=\"$COLOR_MUTED\">MUTE</span>\n"
    else
        local -r vol=$(get_volume)
        local -r color=$(volume_color $vol)

        short_text="<span color=\"$color\">${vol}%</span>\n"
        full_text="<span color=\"$color\">${vol}%</span>\n"

        if isset $MAX_VOLUME && (( $vol > $MAX_VOLUME )); then
            EXITCODE=$EXIT_I3BLOCKS_URGENT
        fi
    fi

    echo -ne "$full_text$short_text"
}

# Outputs the current volume for xob.
output_volume_xob() {
    local -r vol=$(get_volume)

    if is_muted; then
        echo "${vol}!"
    else
        echo "$vol"
    fi
}

# Get color for the given volume
#
# Arguments:
#   $1 - The volume
volume_color() {
    local -r vol=$1

    if $OPT_USE_AMIXER; then
        volume_color_amixer $vol
    else
        volume_color_pulseaudio $vol
    fi
}

# Get color for the given volume for amixer
#
# Arguments:
#   $1 - The volume
volume_color_amixer() {
    local -r vol=$1

    if (( $vol >= 0 && $vol < 100 )); then
        echo "$COLOR_MUTED_TO_BASE"
    elif (( $vol == 100 )); then
        echo "$COLOR_BASE_TO_NORM"
    elif (( $vol > 100 && $vol <= $MAX_VOLUME )); then
        echo "$COLOR_NORM_TO_MAX"
    else
        echo "$COLOR_OTHER"
    fi
}

# Get color for the given volume for PulseAudio
#
# Arguments:
#   $1 - The volume
volume_color_pulseaudio() {
    local -r vol=$1

    if (( $vol >= $PA_VOLUME_MUTED && $vol < $PA_BASE_VOLUME )); then
        echo "$COLOR_MUTED_TO_BASE"
    elif (( $vol >= $PA_BASE_VOLUME && $vol <= $PA_VOLUME_NORM )); then
        echo "$COLOR_BASE_TO_NORM"
    elif (( $vol > $PA_VOLUME_NORM && $vol <= $MAX_VOLUME )); then
        echo "$COLOR_NORM_TO_MAX"
    else
        echo "$COLOR_OTHER"
    fi
}

# Listens for PulseAudio events
listen() {
    local -r index=$(get_sink_index $sink)

    while IFS= read -r event; do
        do_notification
        update_statusbar
    done < <(pactl subscribe | stdbuf -oL grep -e "Event 'change' on sink #$index")
}

# Sends notifications
do_notification() {
    if $OPT_NOTIFICATION; then
        notify_volume
    fi
}

# Updates the status bars
#
# Returns
#   0 when no problem occurred
#   1 when one $of signal or $statusline are set but not both
update_statusbar() {
    if not_empty "$SIGNAL"; then
        if empty "$STATUSLINE"; then
            return 1
        fi
        update_statusline "$SIGNAL" "$STATUSLINE"
    else
        if not_empty "$STATUSLINE"; then
            return 1
        fi
    fi

    return 0
}

# Initialize settings for using PulseAudio
init_pulseaudio() {
    PACMD_LIST_SINKS_OUTPUT=$(pacmd list-sinks) || exit 1

    if empty "$SINK"; then
        SINK="$(get_default_sink_name)"
    fi

    # Determine a max volume when it's not specified
    if isset $MAX_VOLUME; then
        SINK_FLAGS+=( $(get_sink_flags "$SINK") )
        PA_BASE_VOLUME=$(get_base_volume_pulseaudio "$SINK")

        # Does the sink support digital (software) amplification?
        if [[ "${SINK_FLAGS[@]}" =~ "DECIBEL_VOLUME" ]]; then
            MAX_VOLUME=$(($PA_VOLUME_NORM * $MAX_AMPLIFICATION))
        else
            MAX_VOLUME=$PA_VOLUME_NORM
        fi
    fi
}

# Converts milliseconds to seconds with rounding up
#
# Arguments:
#   milliseconds    (integer) An integer in milliseconds
ms_to_secs() {
    echo $(( ($1 + (1000 - 1)) / 1000 ))
}

# Display program usage.
usage() {
    cat <<- EOF 1>&2
Usage: $0 [options]
Control volume and related notifications.

Options:
  -a                                    use alsa-utils instead of pulseaudio-utils for volume control
  -c <card>                             card number to control (amixer only)
  -d <amount>                           decrease volume
  -e <expires>                          expiration time of notifications, in milliseconds
  -i <amount>                           increase volume
  -l                                    use fullcolor instead of symbolic icons
  -L                                    listen for changes to a PulseAudio sink (pulseaudio only)
  -m                                    toggle mute
  -M <mixer>                            specify mixer (ex: Headphone), default Master
  -n                                    show notifications
  -N <libnotify|herbe|xosd>             notification method (default: libnotify)
  -o <generic|i3blocks|xob|\"format\">    output the volume according to the provided output format:
                                            generic    = output the volume
                                            i3blocks   = output the volume for i3blocks
                                            xob        = output the volume for xob
                                            \"format\" = output using a format string. substitutions:
                                                        %v = current volume
  -p                                    show text volume progress bar
  -s <sink_name>                        symbolic name of sink (pulseaudio only)
  -S <suffix>                           add a suffix to symbolic icon names
  -t <process_name>                     name of status line process. must be used with -u
  -u <signal>                           update status line using signal. must be used with -t
  -v <value>                            set volume
  -x <value>                            set maximum volume
  -X <value>                            set maximum amplification (if the device supports it. default: 2)
  -y                                    use dunstify instead of notify-send
  -h                                    display this help and exit
EOF
    exit 1
}

###########################################################
# Non-command line option variables
###########################################################

# Exit codes
declare -ir EXIT_SUCCESS=0
declare -ir EXIT_I3BLOCKS_URGENT=33

declare -i EXITCODE=$EXIT_SUCCESS

declare -a ICONS=(
    audio-volume-muted
    audio-volume-high
    audio-volume-low
    audio-volume-medium
)

declare -a ICONS_SYMBOLIC=(
    audio-volume-muted-symbolic
    audio-volume-high-symbolic
    audio-volume-low-symbolic
    audio-volume-medium-symbolic
    ## Only exists in some icon sets
    # audio-volume-overamplified-symbolic
)

declare -a SINK_FLAGS=()

# Unlike in PA, PA_VOLUME_* in i3-volume are percentages instead of integers
declare -i PA_BASE_VOLUME=100
declare -ir PA_VOLUME_NORM=100
declare -ir PA_VOLUME_MUTED=0

# Cached output of `pacmd list-sinks`; so we don't have to call it each time we need it
PACMD_LIST_SINKS_OUTPUT=""

# Output volume colors
readonly COLOR_MUTED=${COLOR_MUTED:-"#FFFF00"}
readonly COLOR_MUTED_TO_BASE=${COLOR_MUTED_TO_BASE:-"#00FF00"}
readonly COLOR_BASE_TO_NORM=${COLOR_BASE_TO_NORM:-"#FFFF00"}
readonly COLOR_NORM_TO_MAX=${COLOR_NORM_TO_MAX:-"#FF0000"}
readonly COLOR_OTHER=${COLOR_OTHER:-"#FFFFFF"}
readonly COLOR_XOSD_OUTLINE=${COLOR_XOSD_OUTLINE:-"#222222"}

###########################################################
# Command line option variables
###########################################################
declare -l NOTIFICATION_METHOD

OPT_DECREASE_VOLUME=false
OPT_INCREASE_VOLUME=false
OPT_LISTEN=false
OPT_MUTE_VOLUME=false
OPT_NOTIFICATION=false
OPT_SET_VOLUME=false
OPT_SHOW_VOLUME_PROGRESS=false
OPT_USE_AMIXER=false
OPT_USE_DUNSTIFY=false
OPT_USE_FULLCOLOR_ICONS=false
CARD=""
MIXER="Master"
SIGNAL=""
SINK=""
STATUSLINE=""
declare -i VOLUME=5
declare -i EXPIRES=1500
declare -i MAX_VOLUME
declare -i MAX_AMPLIFICATION=2
SYMBOLIC_ICON_SUFFIX=""
OUTPUT_MODE=""
NOTIFICATION_METHOD="libnotify"

while getopts ":ac:d:e:hi:lLmM:nN:o:ps:S:t:u:v:x:X:y" o; do
    case "$o" in
        a)
            OPT_USE_AMIXER=true
            ;;
        c)
            CARD=$OPTARG
            ;;
        d)
            OPT_DECREASE_VOLUME=true
            VOLUME=$OPTARG
            ;;
        e)
            EXPIRES=$OPTARG
            ;;
        i)
            OPT_INCREASE_VOLUME=true
            VOLUME=$OPTARG
            ;;
        l)
            OPT_USE_FULLCOLOR_ICONS=true
            ;;
        L)
            OPT_LISTEN=true
            ;;
        m)
            OPT_MUTE_VOLUME=true
            ;;
        M)
            MIXER=${OPTARG@Q}
            ;;
        n)
            OPT_NOTIFICATION=true
            ;;
        N)
            NOTIFICATION_METHOD=$OPTARG
            ;;
        o)
            OUTPUT_MODE=$OPTARG
            ;;
        p)
            OPT_SHOW_VOLUME_PROGRESS=true
            ;;
        s)
            SINK=$OPTARG
            ;;
        S)
            SYMBOLIC_ICON_SUFFIX=$OPTARG
            ;;
        t)
            STATUSLINE=$OPTARG
            ;;
        u)
            SIGNAL=$OPTARG
            ;;
        v)
            OPT_SET_VOLUME=true
            VOLUME=$OPTARG
            ;;
        x)
            MAX_VOLUME=$OPTARG
            ;;
        X)
            MAX_AMPLIFICATION=$OPTARG
            ;;
        y)
            OPT_USE_DUNSTIFY=true
            ;;
        h | *)
            usage
            ;;
    esac
done
shift $((OPTIND-1)) # Shift off options and optional --

# Default to PA when amixer is not specified
if ! $OPT_USE_AMIXER; then
    init_pulseaudio
fi

if $OPT_INCREASE_VOLUME; then
    raise_volume $VOLUME $MAX_VOLUME
fi

if $OPT_DECREASE_VOLUME; then
    lower_volume $VOLUME
fi

if $OPT_SET_VOLUME; then
    set_volume $VOLUME $MAX_VOLUME
fi

if $OPT_MUTE_VOLUME; then
    toggle_mute
fi

if not_empty "$SYMBOLIC_ICON_SUFFIX"; then
    apply_SYMBOLIC_ICON_SUFFIX
fi

# The options below this line must be last
if $OPT_LISTEN; then
    listen
else
    do_notification

    update_statusbar || usage

    if not_empty "$OUTPUT_MODE"; then
        output_volume

        exit ${EXITCODE:-$EXIT_SUCCESS}
    fi
fi

exit ${EXITCODE:-$EXIT_SUCCESS}
